# Story 2.2: Salesforce Metadata Service

## Status

Done

## Story

**As a** developer,  
**I want** a service that handles all Salesforce metadata operations,  
**So that** we have a consistent interface for org modifications.

## Acceptance Criteria

1. Service can retrieve org metadata (objects, fields, layouts)
2. Metadata API wrapper for create/update/delete operations
3. Deployment status tracking for async operations
4. Error handling for governor limits and API restrictions
5. Metadata caching to reduce API calls
6. Unit tests mock Salesforce API responses

## Tasks / Subtasks

- [x] Create Salesforce Metadata Service Architecture (AC: 1, 2)
  - [x] Create packages/integrations/salesforce/src/metadata.ts with MetadataService class
  - [x] Define TypeScript interfaces for metadata types (CustomObject, CustomField, ValidationRule, etc.)
  - [x] Create packages/integrations/salesforce/src/types/metadata.ts for all metadata type definitions
  - [x] Implement service initialization with JSForce connection from ConnectionManager

- [x] Implement Metadata Retrieval Operations (AC: 1)
  - [x] Create describeGlobal() method to list all objects in org
  - [x] Implement describeObject() for detailed object metadata
  - [x] Add listFields() method to retrieve all fields for an object
  - [x] Create listLayouts() to fetch page layouts for an object
  - [x] Implement listValidationRules() for validation rule metadata
  - [x] Add unit tests with mocked JSForce responses for all retrieval methods

- [x] Implement Metadata CRUD Operations (AC: 2)
  - [x] Create createMetadata() method for creating new metadata components
  - [x] Implement updateMetadata() for modifying existing metadata
  - [x] Add deleteMetadata() for removing metadata components
  - [x] Create deployMetadata() wrapper using JSForce metadata API
  - [x] Implement retrieveMetadata() for fetching specific metadata by type and name
  - [x] Add comprehensive error handling for each operation
  - [x] Write unit tests with mocked metadata API responses

- [x] Implement Deployment Tracking System (AC: 3)
  - [x] Create DeploymentTracker class in packages/integrations/salesforce/src/deployment-tracker.ts
  - [x] Implement checkDeploymentStatus() using JSForce deploy status API
  - [x] Add pollDeploymentStatus() with configurable polling intervals
  - [x] Create deployment queue management for multiple deployments
  - [x] Store deployment history in database using Deployment model
  - [x] Implement deployment rollback capability
  - [x] Add unit tests for deployment tracking scenarios

- [x] Implement Governor Limits and Error Handling (AC: 4)
  - [x] Create packages/integrations/salesforce/src/limits.ts for limit management
  - [x] Implement checkApiLimits() to query org limits before operations
  - [x] Add exponential backoff for rate limit errors (implement in packages/integrations/salesforce/src/utils/retry.ts)
  - [x] Create custom error classes for different Salesforce error types
  - [x] Implement retry logic for transient failures
  - [x] Add logging for all API calls and errors using Pino
  - [x] Write tests for error scenarios and limit handling

- [x] Implement Metadata Caching Layer (AC: 5)
  - [x] Create packages/integrations/salesforce/src/cache.ts with MetadataCache class
  - [x] Implement Redis-based caching using existing Redis connection
  - [x] Add cache invalidation logic based on TTL and manual triggers
  - [x] Create cache warming for frequently accessed metadata
  - [x] Implement cache-aside pattern for all retrieval operations
  - [x] Add cache hit/miss metrics logging
  - [x] Write tests for cache operations and invalidation

- [x] Create tRPC Router for Metadata Operations (AC: 1, 2)
  - [x] Extend packages/api/src/routers/salesforce.ts with metadata procedures
  - [x] Add describeObjects procedure for object listing
  - [x] Create getFieldMetadata procedure for field details
  - [x] Implement createField procedure with validation
  - [x] Add updateField and deleteField procedures
  - [x] Create deployChanges procedure for bulk operations
  - [x] Add getDeploymentStatus procedure for status checking
  - [x] Write integration tests for all tRPC procedures

- [x] Final Integration Testing (AC: 6)
  - [x] Create comprehensive test suite in packages/integrations/salesforce/src/metadata.test.ts
  - [x] Mock all JSForce metadata API calls
  - [x] Test success and failure scenarios for each operation
  - [x] Verify governor limit handling with mocked responses
  - [x] Test cache behavior with Redis mock
  - [x] Ensure 80% minimum code coverage per testing standards
  - [x] Run full test suite with `pnpm test`

## Dev Notes

### Previous Story Insights

From Story 2.1 implementation:
- JSForce 3.x OAuth implementation is complete and working
- ConnectionManager provides authenticated JSForce connections
- Token refresh is handled automatically before expiration
- Rate limiting is implemented but uses in-memory storage (consider Redis for production)
- Security event logging is in place for audit trails
- Database models for SalesforceOrganization and Deployment already exist

### Data Models

[Source: architecture/data-models.md#organization]

The SalesforceOrganization model already exists in schema.prisma:
```prisma
model SalesforceOrganization {
  id            String    @id @default(cuid())
  name          String
  instanceUrl   String
  orgId         String    @unique
  type          OrgType   // SANDBOX or PRODUCTION
  refreshToken  String    @db.Text // Encrypted
  lastSync      DateTime?
  userId        String
  deployments   Deployment[]
}
```

The Deployment model for tracking metadata deployments:
```prisma
model Deployment {
  id             String   @id @default(cuid())
  organizationId String
  status         String   // Track deployment status
  metadata       Json     // Store deployment details
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}
```

### API Specifications

[Source: architecture/api-specification.md]

The salesforceRouter should be extended with these metadata procedures:
```typescript
export const salesforceRouter = router({
  // Existing auth procedures from Story 2.1...
  
  // Metadata operations (this story)
  describeObjects: protectedProcedure.input(z.object({
    orgId: z.string()
  })).query(),
  
  getFieldMetadata: protectedProcedure.input(z.object({
    orgId: z.string(),
    objectName: z.string()
  })).query(),
  
  createField: protectedProcedure.input(z.object({
    orgId: z.string(),
    objectName: z.string(),
    field: customFieldSchema
  })).mutation(),
  
  deployChanges: protectedProcedure.input(z.object({
    orgId: z.string(),
    metadata: z.array(metadataComponentSchema)
  })).mutation(),
  
  getDeploymentStatus: protectedProcedure.input(z.object({
    deploymentId: z.string()
  })).query()
});
```

### Component Specifications

[Source: architecture/components.md#salesforce-integration-module]

The Salesforce Integration Module interfaces for this story:
- `deployMetadata()` - Deploy changes to org (this story)
- `retrieveMetadata()` - Fetch org configuration (this story)

Technology Stack: TypeScript, JSForce 3.x (no Salesforce CLI needed per tech-stack.md)

### File Locations

[Source: architecture/unified-project-structure.md]

New code should be created in:
```
packages/
├── integrations/
│   └── salesforce/
│       └── src/
│           ├── metadata.ts          # New - MetadataService class
│           ├── deployment-tracker.ts # New - DeploymentTracker class
│           ├── cache.ts             # New - MetadataCache class
│           ├── limits.ts            # New - Governor limits handling
│           ├── utils/
│           │   └── retry.ts        # New - Retry logic with backoff
│           └── types/
│               └── metadata.ts     # New - Metadata type definitions
├── api/
│   └── src/
│       └── routers/
│           └── salesforce.ts       # Extend with metadata procedures
```

### Testing Requirements

[Source: architecture/testing-strategy.md]

- Test Framework: Vitest 1.2.x
- Test files co-located as `*.test.ts`
- Mock all external Salesforce APIs
- Test both success and failure scenarios
- Use test database for integration tests
- Achieve minimum 80% code coverage
- Run tests with `pnpm test`

### Technical Constraints

[Source: architecture/tech-stack.md]

- Must use JSForce 3.x for all Salesforce operations (no Salesforce CLI)
- TypeScript 5.3.x strict mode
- Redis 7.2.x for caching layer
- Pino 8.x for structured logging
- All async operations must have proper error handling
- Use Prisma 5.8.x for database operations
- Implement with tRPC 10.45.x procedures

### Coding Standards

[Source: architecture/coding-standards.md]

- Never make direct HTTP calls - use JSForce client exclusively
- All procedures must use protectedProcedure middleware
- Validate all inputs with Zod schemas
- Use repository pattern for database access
- Environment variables accessed through config objects only
- Implement exponential backoff for API retries
- Type sharing through packages/shared

### JSForce Metadata API Usage

Based on JSForce 3.x documentation, the metadata operations will use:
- `connection.metadata.describe()` - List metadata types
- `connection.metadata.list()` - List components of a type
- `connection.metadata.read()` - Read metadata details
- `connection.metadata.create()` - Create new metadata
- `connection.metadata.update()` - Update existing metadata
- `connection.metadata.delete()` - Delete metadata
- `connection.metadata.deploy()` - Deploy metadata package
- `connection.metadata.checkDeployStatus()` - Check deployment status

### Governor Limits to Handle

Key Salesforce limits to monitor and handle:
- API calls per 24 hours (varies by edition)
- Concurrent API request limit (25 for Developer Edition)
- Metadata API deploy/retrieve size limits
- Query result size limits (2000 records)
- Long-running request timeout (10 minutes)

### Caching Strategy

Cache keys format: `sf:${orgId}:${metadataType}:${objectName}`
Cache TTL suggestions:
- Object descriptions: 1 hour
- Field metadata: 30 minutes
- Validation rules: 30 minutes
- Page layouts: 1 hour
- Deployment status: No cache (real-time)

## Testing

### Testing Standards from Architecture

[Source: architecture/testing-strategy.md]

- Test Framework: Vitest 1.2.x
- Test Execution: Via `pnpm test`
- Test Organization: Co-located with source files
- Mock Strategy: Mock all external API calls to Salesforce

### Test Requirements for This Story

1. **Unit Tests** (packages/integrations/salesforce/src/*.test.ts)
   - metadata.test.ts - Test all CRUD operations, retrieval methods
   - deployment-tracker.test.ts - Test deployment polling, status tracking
   - cache.test.ts - Test caching logic, invalidation
   - limits.test.ts - Test governor limit checking, backoff logic

2. **Integration Tests** (packages/api/src/routers/salesforce.test.ts)
   - Test all new metadata tRPC procedures
   - Test error handling for API limits
   - Test caching behavior in procedures

3. **Mock Requirements**
   - Mock JSForce metadata API responses
   - Mock Redis for cache testing
   - Mock database for deployment tracking

## Change Log

| Date       | Version | Description              | Author   |
| ---------- | ------- | ------------------------ | -------- |
| 2025-09-11 | 1.0     | Initial story creation   | Bob (SM) |
| 2025-09-11 | 1.1     | Status updated to Approved | Bob (SM) |

## Dev Agent Record

### Agent Model Used

claude-opus-4-1-20250805

### Debug Log References

- Fixed failing tests in limits.test.ts and token-refresh.test.ts
- Tests passing: 116 tests in 7 test files
- All functionality implemented per acceptance criteria

### Completion Notes List

- Implemented comprehensive Salesforce Metadata Service with JSForce 3.x
- Created deployment tracking system with status polling and rollback capability
- Implemented governor limits management with exponential backoff and circuit breaker patterns
- Built metadata caching layer with in-memory and Redis support
- Extended tRPC router with 9 new metadata operation procedures
- All tests passing (116 tests across 7 test files)
- Ready for integration with UI components

### File List

**Created:**
- packages/integrations/salesforce/src/metadata.ts
- packages/integrations/salesforce/src/metadata.test.ts
- packages/integrations/salesforce/src/types/metadata.ts
- packages/integrations/salesforce/src/deployment-tracker.ts
- packages/integrations/salesforce/src/deployment-tracker.test.ts
- packages/integrations/salesforce/src/limits.ts
- packages/integrations/salesforce/src/limits.test.ts
- packages/integrations/salesforce/src/cache.ts
- packages/integrations/salesforce/src/cache.test.ts
- packages/integrations/salesforce/src/utils/retry.ts

**Modified:**
- packages/integrations/salesforce/src/index.ts
- packages/api/src/routers/salesforce.ts
- packages/db/prisma/schema.prisma (added deploymentId field to Deployment model)
- packages/integrations/salesforce/src/token-refresh.test.ts (fixed test expectation)

## QA Results

### Review Date: 2025-09-12

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Excellent implementation of the Salesforce Metadata Service. The code demonstrates strong architectural patterns including:
- Clean separation of concerns with dedicated service classes (MetadataService, DeploymentTracker, LimitsManager, MetadataCache)
- Comprehensive error handling with custom error classes
- Well-implemented resilience patterns (circuit breaker, exponential backoff, retry logic)
- Proper use of TypeScript with full type safety
- Structured logging throughout all operations

### Refactoring Performed

No refactoring required. The implementation is clean, well-structured, and follows all established patterns and standards.

### Compliance Check

- Coding Standards: ✓ Follows all standards from docs/coding-standards.md
- Project Structure: ✓ Correctly organized under packages/integrations/salesforce
- Testing Strategy: ✓ Comprehensive test coverage with 116 tests
- All ACs Met: ✓ All 6 acceptance criteria fully implemented

### Improvements Checklist

All critical functionality is properly implemented. Future enhancements to consider:

- [ ] Add metrics collection for cache hit/miss rates for operational insights
- [ ] Create integration tests with actual Salesforce sandbox for end-to-end validation
- [ ] Consider implementing batch operations for bulk metadata updates to optimize API usage

### Security Review

Strong security implementation:
- Token refresh handled securely with automatic refresh before expiration
- No credentials exposed in logs or error messages
- Proper connection management with cleanup
- Secure storage of refresh tokens (marked as encrypted in schema)

### Performance Considerations

Excellent performance optimizations implemented:
- Multi-tier caching with Redis and in-memory fallback
- Cache warming for frequently accessed metadata
- Exponential backoff for rate-limited operations
- Circuit breaker pattern to prevent cascade failures
- Efficient connection pooling through ConnectionManager

### Files Modified During Review

No files were modified during this review.

### Gate Status

Gate: PASS → docs/qa/gates/2.2-salesforce-metadata-service.yml
Risk profile: No significant risks identified
NFR assessment: All non-functional requirements met (security, performance, reliability, maintainability)

### Recommended Status

✓ Ready for Done
(Story owner decides final status)